#!/usr/bin/env python3
"""
Sentinel Manufacturing Defense Platform - Ghost CNC Simulator
Physics-based virtual CNC machine with thermal dynamics and vibration modeling

Author: Angel L. Pinzon
License: MIT
"""

import math
import time
import json
import random
from dataclasses import dataclass, asdict
from typing import Optional, Dict
import paho.mqtt.client as mqtt
from datetime import datetime


@dataclass
class ThermalModel:
    """
    First-order thermal system modeling heat transfer
    Based on Newton's Law of Cooling: dT/dt = (Q_in - Q_out) / C
    """
    temp: float = 25.0          # Current temperature (Â°C)
    ambient: float = 22.0       # Ambient shop temperature
    thermal_mass: float = 850.0 # Thermal capacitance (J/Â°C)
    cooling_coeff: float = 0.18 # Heat transfer coefficient
    coolant_flow: float = 1.0   # Coolant effectiveness (0-1)
    
    def step(self, heat_input: float, dt: float = 1.0) -> float:
        """
        Update thermal state using discrete time integration
        
        Args:
            heat_input: Heat generated by cutting (Watts)
            dt: Time step (seconds)
            
        Returns:
            Updated temperature (Â°C)
        """
        # Effective cooling (reduced if coolant fails)
        effective_cooling = self.cooling_coeff * self.coolant_flow
        
        # Heat removal via convection and coolant
        heat_removal = effective_cooling * (self.temp - self.ambient)
        
        # Thermal dynamics (Euler integration)
        dT = (heat_input - heat_removal) / self.thermal_mass
        self.temp += dT * dt
        
        # Physical limit (can't go below ambient)
        self.temp = max(self.temp, self.ambient)
        
        return self.temp


@dataclass
class VibrationModel:
    """
    Vibration analysis based on bearing wear progression
    Combines baseline vibration, harmonic content, and defect signatures
    """
    base_vibration: float = 0.0008  # Healthy baseline (mm/s RMS)
    wear_coefficient: float = 0.0    # Bearing wear state (0-1)
    defect_severity: float = 0.0     # Injected defect magnitude
    
    def get_vibration(self, rpm: float, load: float, temp: float) -> float:
        """
        Calculate instantaneous vibration amplitude
        
        Vibration sources:
        1. Imbalance (proportional to RPMÂ²)
        2. Bearing wear (exponential growth after threshold)
        3. Temperature-induced expansion
        4. Injected defects (for testing)
        """
        if rpm < 100:  # Machine stopped
            return self.base_vibration
        
        # Imbalance vibration (grows with square of RPM)
        imbalance = 0.000001 * (rpm ** 2) * load
        
        # Bearing wear (becomes significant after 30% wear)
        if self.wear_coefficient > 0.3:
            wear_factor = math.exp((self.wear_coefficient - 0.3) * 5)
            wear_vib = 0.008 * wear_factor
        else:
            wear_vib = 0.0
        
        # Thermal expansion effects (loose fit above 85Â°C)
        if temp > 85.0:
            thermal_vib = 0.002 * (temp - 85.0) / 15.0  # Linear growth
        else:
            thermal_vib = 0.0
        
        # Defect impulse (ball bearing spall signature)
        defect_vib = self.defect_severity * 0.04 * (rpm / 5000)
        
        # Random process noise (Â±10% variation)
        noise = random.gauss(1.0, 0.1)
        
        total = (self.base_vibration + imbalance + wear_vib + 
                 thermal_vib + defect_vib) * noise
        
        return max(0.0, total)


class GhostCNC:
    """
    Virtual CNC Machine with physics-based behavior
    
    Simulates:
    - Spindle thermal dynamics
    - Vibration frequency content
    - Power consumption
    - Gradual wear progression
    - Fault injection for testing
    """
    
    def __init__(self, machine_id: str = "GHOST-001", broker: str = "localhost"):
        self.id = machine_id
        self.broker = broker
        
        # Physics models
        self.thermal = ThermalModel()
        self.vibration = VibrationModel()
        
        # Machine state
        self.rpm = 0
        self.feed_rate = 100  # Percentage of commanded
        self.spindle_load = 0.0  # Cutting torque (0-1 normalized)
        self.power_draw = 0.0  # kW
        self.running = True
        self.cycle_time = 0.0
        
        # Fault states (for chaos engineering)
        self.coolant_failure = False
        self.bearing_defect = False
        self.overload_condition = False
        
        # Operational history
        self.total_runtime_hours = 0.0
        self.total_cuts = 0
        
        # MQTT client
        self.mqtt_client = mqtt.Client(client_id=f"simulator_{machine_id}")
        self.mqtt_client.on_connect = self._on_mqtt_connect
        
        try:
            self.mqtt_client.connect(broker, 1883, 60)
            self.mqtt_client.loop_start()
        except Exception as e:
            print(f"[WARNING] MQTT broker not available: {e}")
            print(f"[INFO] Running in standalone mode. Start broker with:")
            print(f"       docker run -d -p 1883:1883 eclipse-mosquitto:2")
    
    def _on_mqtt_connect(self, client, userdata, flags, rc):
        """MQTT connection callback"""
        if rc == 0:
            print(f"[MQTT] {self.id} connected to broker at {self.broker}")
            # Subscribe to command topic
            client.subscribe(f"factory/{self.id}/command")
            client.message_callback_add(f"factory/{self.id}/command", 
                                       self._on_command)
        else:
            print(f"[MQTT] Connection failed with code {rc}")
    
    def _on_command(self, client, userdata, msg):
        """Handle incoming control commands from Sentinel Agent"""
        try:
            cmd = json.loads(msg.payload.decode())
            action = cmd.get("action")
            value = cmd.get("value", 0.0)
            
            if action == "set_feed":
                self.feed_rate = max(0, min(100, value))
                # Reduce load proportionally
                self.spindle_load *= (value / 100.0)
                print(f"[CMD] {self.id}: Feed rate set to {self.feed_rate:.1f}%")
                
            elif action == "emergency_stop":
                self.rpm = 0
                self.spindle_load = 0
                self.running = False
                print(f"[CMD] {self.id}: EMERGENCY STOP executed")
                
            elif action == "reduce_thermal_load":
                # Agent attempting thermal management
                self.rpm = int(self.rpm * 0.7)
                self.spindle_load *= 0.6
                print(f"[CMD] {self.id}: Thermal load reduction applied")
                
            elif action == "resume":
                self.running = True
                print(f"[CMD] {self.id}: Operation resumed")
                
        except json.JSONDecodeError:
            print(f"[ERROR] Invalid command JSON: {msg.payload}")
    
    def step(self, dt: float = 1.0):
        """
        Physics simulation update (called every second)
        
        Args:
            dt: Time step in seconds
        """
        if not self.running:
            # Cooldown when stopped
            self.thermal.step(heat_input=0, dt=dt)
            self._publish_telemetry()
            return
        
        # Heat generation model (simplified)
        # Power = Torque Ã— Angular Velocity
        # Heat = Power Ã— (1 - Efficiency)
        if self.rpm > 0:
            torque = self.spindle_load * 50.0  # Nm (normalized)
            omega = self.rpm * 2 * math.pi / 60  # rad/s
            power = torque * omega  # Watts
            self.power_draw = power / 1000.0  # kW
            
            # Assume 85% mechanical efficiency, 15% becomes heat
            heat_generation = power * 0.15
        else:
            heat_generation = 0.0
            self.power_draw = 0.0
        
        # Update thermal state
        if self.coolant_failure:
            # Coolant failure = 80% reduction in cooling effectiveness
            self.thermal.coolant_flow = 0.2
        else:
            self.thermal.coolant_flow = 1.0
        
        temp = self.thermal.step(heat_generation, dt)
        
        # Bearing wear accumulation (Arrhenius-like temperature dependency)
        if temp > 75.0:
            wear_rate = 0.00008 * math.exp((temp - 75.0) / 25.0)
            self.vibration.wear_coefficient += wear_rate * dt
            # Cap at 100% wear
            self.vibration.wear_coefficient = min(1.0, self.vibration.wear_coefficient)
        
        # Bearing defect injection
        if self.bearing_defect:
            self.vibration.defect_severity = 0.75
        
        # Calculate vibration
        vib = self.vibration.get_vibration(self.rpm, self.spindle_load, temp)
        
        # Update runtime
        self.total_runtime_hours += dt / 3600.0
        
        # Publish telemetry
        self._publish_telemetry()
    
    def _publish_telemetry(self):
        """Publish machine state to MQTT broker"""
        # Determine thermal state
        if self.thermal.temp > 95.0:
            thermal_state = "critical"
        elif self.thermal.temp > 80.0:
            thermal_state = "warning"
        else:
            thermal_state = "normal"
        
        # Calculate vibration state
        vib_current = self.vibration.get_vibration(
            self.rpm, self.spindle_load, self.thermal.temp
        )
        
        if vib_current > 0.05:  # ISO 10816 Category D (not permissible)
            vibration_state = "critical"
        elif vib_current > 0.02:  # Category C (unsatisfactory)
            vibration_state = "warning"
        else:
            vibration_state = "normal"
        
        telemetry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "machine_id": self.id,
            "spindle": {
                "rpm": self.rpm,
                "temp": round(self.thermal.temp, 2),
                "vibration": round(vib_current, 5),
                "load_percent": round(self.spindle_load * 100, 1),
                "feed_rate": self.feed_rate,
            },
            "power": {
                "draw_kw": round(self.power_draw, 3),
            },
            "health": {
                "thermal_state": thermal_state,
                "vibration_state": vibration_state,
                "wear_percent": round(self.vibration.wear_coefficient * 100, 2),
                "runtime_hours": round(self.total_runtime_hours, 1),
            },
            "faults": {
                "coolant_failure": self.coolant_failure,
                "bearing_defect": self.bearing_defect,
            },
            "status": "running" if self.running else "stopped"
        }
        
        # Publish to MQTT
        topic = f"factory/{self.id}/telemetry"
        try:
            self.mqtt_client.publish(topic, json.dumps(telemetry), qos=1)
        except Exception as e:
            # Fail silently if broker unavailable (for testing)
            pass
    
    def inject_chaos(self, fault_type: str):
        """
        Chaos engineering - inject faults for testing/demo
        
        Fault types:
        - coolant_failure: Pump failure (thermal runaway)
        - bearing_defect: Pre-existing bearing damage
        - overload: Excessive cutting forces
        """
        if fault_type == "coolant_failure":
            self.coolant_failure = True
            print(f"\nðŸ”´ [CHAOS] Coolant pump failure injected on {self.id}")
            print(f"    Expected: Thermal runaway in ~3-5 minutes")
            
        elif fault_type == "bearing_defect":
            self.vibration.defect_severity = 0.8
            self.bearing_defect = True
            print(f"\nðŸ”´ [CHAOS] Bearing defect injected on {self.id}")
            print(f"    Expected: Vibration spike, maintenance alert")
            
        elif fault_type == "overload":
            self.spindle_load = 0.95  # 95% of rated torque
            self.overload_condition = True
            print(f"\nðŸ”´ [CHAOS] Cutting overload injected on {self.id}")
            print(f"    Expected: High power draw, thermal stress")
            
        else:
            print(f"[ERROR] Unknown fault type: {fault_type}")
    
    def start_cutting_cycle(self, rpm: int = 4500, load: float = 0.65):
        """Begin normal cutting operation"""
        self.running = True
        self.rpm = rpm
        self.spindle_load = load
        self.total_cuts += 1
        print(f"[CYCLE] {self.id}: Started cutting at {rpm} RPM, {load*100:.1f}% load")


def run_demo_scenario():
    """
    Pre-programmed demo scenario for pitch presentations
    Shows thermal runaway detection and autonomous response
    """
    print("=" * 60)
    print("SENTINEL MANUFACTURING DEFENSE - GHOST CNC SIMULATOR")
    print("Demo Scenario: Coolant Failure Detection & Response")
    print("=" * 60)
    
    machine = GhostCNC("GHOST-DEMO-001")
    
    # Phase 1: Normal operation (30 seconds)
    print("\n[PHASE 1] Normal cutting operation...")
    machine.start_cutting_cycle(rpm=5000, load=0.7)
    
    for i in range(30):
        machine.step()
        if i % 5 == 0:  # Print status every 5 seconds
            print(f"  âœ“ t={i:2d}s | Temp: {machine.thermal.temp:5.1f}Â°C | "
                  f"Vib: {machine.vibration.get_vibration(machine.rpm, machine.spindle_load, machine.thermal.temp):.4f} mm/s")
        time.sleep(0.5)  # Accelerated time (0.5s real = 1s simulated)
    
    # Phase 2: Inject fault
    print("\n[PHASE 2] INJECTING FAULT: Coolant pump failure")
    machine.inject_chaos("coolant_failure")
    
    # Phase 3: Watch thermal runaway
    print("\n[PHASE 3] Monitoring thermal response (Sentinel should detect)...")
    for i in range(60):
        machine.step()
        
        temp = machine.thermal.temp
        vib = machine.vibration.get_vibration(machine.rpm, machine.spindle_load, temp)
        
        # Print critical updates
        if temp > 75 and i % 3 == 0:
            print(f"  âš ï¸  t={i:2d}s | Temp: {temp:5.1f}Â°C (â†‘) | Vib: {vib:.4f} mm/s")
        
        # Simulate agent response at 85Â°C threshold
        if temp > 85.0 and machine.running:
            print(f"\n  âš¡ SENTINEL AGENT INTERVENTION (simulated)")
            print(f"     Detection: Thermal runaway (temp={temp:.1f}Â°C)")
            print(f"     Action: Reducing spindle speed by 50%")
            machine.rpm = int(machine.rpm * 0.5)
            machine.spindle_load *= 0.5
            break
        
        time.sleep(0.5)
    
    # Phase 4: Recovery
    print("\n[PHASE 4] Cooldown and recovery...")
    for i in range(30):
        machine.step()
        if i % 5 == 0:
            print(f"  â†“ t={i:2d}s | Temp: {machine.thermal.temp:5.1f}Â°C (cooling)")
        time.sleep(0.5)
    
    print("\n" + "=" * 60)
    print("DEMO COMPLETE")
    print(f"Final State: Temp={machine.thermal.temp:.1f}Â°C, Status={'Safe' if machine.thermal.temp < 80 else 'Warning'}")
    print("=" * 60)


def run_continuous_fleet():
    """
    Run multiple machines continuously for dashboard testing
    Simulates a small factory floor
    """
    print("=" * 60)
    print("GHOST FACTORY - CONTINUOUS FLEET SIMULATION")
    print("=" * 60)
    print("\nStarting 5 virtual CNC machines...")
    print("Press Ctrl+C to stop\n")
    
    # Create fleet
    fleet = [
        GhostCNC(f"CNC-{i:03d}") for i in range(1, 6)
    ]
    
    # Start with different operating conditions
    fleet[0].start_cutting_cycle(rpm=4800, load=0.65)
    fleet[1].start_cutting_cycle(rpm=5200, load=0.70)
    fleet[2].start_cutting_cycle(rpm=4500, load=0.60)
    fleet[3].start_cutting_cycle(rpm=5000, load=0.75)
    fleet[4].rpm = 0  # One machine idle
    
    # Optional: Inject a fault for testing
    # Uncomment to create an incident for dashboard testing
    # fleet[2].inject_chaos("coolant_failure")
    
    try:
        step_count = 0
        while True:
            for machine in fleet:
                machine.step()
            
            # Status update every 10 seconds
            if step_count % 10 == 0:
                print(f"\n[t={step_count}s] Fleet Status:")
                for machine in fleet:
                    status_icon = "âœ“" if machine.thermal.temp < 80 else "âš ï¸"
                    print(f"  {status_icon} {machine.id}: "
                          f"{machine.thermal.temp:5.1f}Â°C | "
                          f"{machine.rpm:4d} RPM | "
                          f"{machine.thermal.coolant_flow*100:.0f}% coolant")
            
            step_count += 1
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\n\nShutting down fleet...")
        for machine in fleet:
            machine.mqtt_client.loop_stop()
            machine.mqtt_client.disconnect()
        print("Fleet stopped.")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "demo":
        # Run pre-scripted demo
        run_demo_scenario()
    else:
        # Run continuous fleet for dashboard testing
        run_continuous_fleet()
